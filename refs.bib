
@article{raschka2020machine,
  title={Machine Learning in Python: Main developments and technology trends in data science, machine learning, and artificial intelligence},
  author={Raschka, Sebastian and Patterson, Joshua and Nolet, Corey},
  journal={arXiv preprint arXiv:2002.04803},
  year={2020}
}

@online{gplearn,
  title={gplearn: Genetic Programming in Python, with a scikit-learn inspired API},
  author={Trevor Stephens},
  year={2015},
  url={https://github.com/trevorstephens/gplearn},
}

@book{Koza92,
  added-at = {2008-11-22T15:57:31.000+0100},
  address = {Cambridge, MA, USA},
  author = {Koza, John R.},
  biburl = {https://www.bibsonomy.org/bibtex/27573e564bc5369e1a853e74b3ac62607/emanuel},
  interhash = {e8307fb6cf4ee27405142256d98c4c9e},
  intrahash = {7573e564bc5369e1a853e74b3ac62607},
  isbn = {0-262-11170-5},
  keywords = {enumerative_ip gp induction inductive_programming program_evolution program_synthesis},
  publisher = {MIT Press},
  timestamp = {2008-11-22T15:57:31.000+0100},
  title = {Genetic Programming: {O}n the Programming of Computers by Means of Natural Selection},
  year = 1992
}

@article{luke:2000:2ftcaGP,
  abstract = {Genetic programming is an evolutionary optimization
                 method that produces functional programs to solve a
                 given task. These programs commonly take the form of
                 trees representing LISP s-expressions, and a typical
                 evolutionary run produces a great many of these trees.
                 For this reason, a good tree generation algorithm is
                 very important to genetic programming. This paper
                 presents two new tree-generation algorithms for genetic
                 programming and for strongly-typed genetic programming,
                 a common variant. These algorithms are fast, allow the
                 user to request specific tree sizes, and guarantee
                 probabilities of certain nodes appearing in trees. The
                 paper analyzes these two algorithms and compares them
                 with traditional and recently proposed approaches.},
  added-at = {2008-06-19T17:35:00.000+0200},
  author = {Luke, Sean},
  biburl = {https://www.bibsonomy.org/bibtex/2788f8ce76795eab433443e38bb61b417/brazovayeye},
  interhash = {ae9f9a3a7c853e3db8ef4b656cd2713f},
  intrahash = {788f8ce76795eab433443e38bb61b417},
  journal = {IEEE Transactions on Evolutionary Computation},
  keywords = {Bloat Creation, Growth, Initialization, Introns, Mutation, Population Subtree Tree algorithms, genetic programming,},
  month = {September},
  number = 3,
  pages = {274--283},
  size = {9 pages},
  timestamp = {2008-06-19T17:45:57.000+0200},
  title = {Two Fast Tree-Creation Algorithms for Genetic
                 Programming},
  url = {http://citeseer.ist.psu.edu/409667.html},
  volume = 4,
  year = 2000
}

@article{scikit-learn,
 title={Scikit-learn: Machine Learning in {P}ython},
 author={Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V.
         and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P.
         and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and
         Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
 journal={Journal of Machine Learning Research},
 volume={12},
 pages={2825--2830},
 year={2011}
}

@book{poli08:fieldguide,
  abstract = {Genetic programming (GP) is a systematic,
                 domain-independent method for getting computers to
                 solve problems automatically starting from a high-level
                 statement of what needs to be done. Using ideas from
                 natural evolution, GP starts from an ooze of random
                 computer programs, and progressively refines them
                 through processes of mutation and sexual recombination,
                 until high-fitness solutions emerge. All this without
                 the user having to know or specify the form or
                 structure of solutions in advance. GP has generated a
                 plethora of human-competitive results and applications,
                 including novel scientific discoveries and patentable
                 inventions.

                 This unique overview of this exciting technique is
                 written by three of the most active scientists in GP.
                 See www.gp-field-guide.org.uk for more information on
                 the book.

                 Table of Contents

                 1 Introduction

                 1.1 Genetic Programming in a Nutshell

                 1.2 Getting Started

                 1.3 Prerequisites

                 1.4 Overview of this Field Guide

                 Part I Basics

                 2 Representation, Initialisation and Operators in
                 Tree-based GP

                 2.1 Representation

                 2.2 Initialising the Population

                 2.3 Selection

                 2.4 Recombination and Mutation},
  added-at = {2008-06-19T17:46:40.000+0200},
  author = {Poli, Riccardo and Langdon, William B. and McPhee, Nicholas Freitag},
  biburl = {https://www.bibsonomy.org/bibtex/2f48362d42a42bda317f0bbc62617bec4/brazovayeye},
  interhash = {938fd34df032d412c170727b7ccbdc9a},
  intrahash = {f48362d42a42bda317f0bbc62617bec4},
  isbn13 = {978-1-4092-0073-4},
  keywords = {algorithms, artificial automatic computation evolutionary genetic intelligence, learning, machine programming,},
  note = {(With contributions by J. R. Koza)},
  notes = {http://www.gp-field-guide.org.uk/},
  publisher = {Published via \texttt{http://lulu.com} and freely
                 available at
                 \texttt{http://www.gp-field-guide.org.uk}},
  size = {250 pages},
  timestamp = {2008-06-19T17:49:49.000+0200},
  title = {A field guide to genetic programming},
  url = {http://www.gp-field-guide.org.uk},
  year = 2008
}

@misc{staats2017tensorflow,
      title={TensorFlow Enabled Genetic Programming}, 
      author={Kai Staats and Edward Pantridge and Marco Cavaglia and Iurii Milovanov and Arun Aniyan},
      year={2017},
      eprint={1708.03157},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}

@misc{Dua:2019 ,
  author = "Dua, Dheeru and Graff, Casey",
  year = "2017",
  title = "{UCI} Machine Learning Repository",
  url = "http://archive.ics.uci.edu/ml",
  institution = "University of California, Irvine, School of Information and Computer Sciences" 
} 

@article{perkis, 
  title={Stack-based genetic programming}, 
  DOI={10.1109/icec.1994.350025},
  year="1994", 
  journal={Proceedings of the First IEEE Conference on Evolutionary Computation. IEEE World Congress on Computational Intelligence}, 
  author={Perkis, T.}
} 

@inproceedings{baeta2021tensorgp,
	title = {TensorGP -- Genetic Programming Engine in TensorFlow},
	author = {Baeta, Francisco and Correia, Jo{\~{a}}o and Martins, Tiago and Machado, Penousal},
	booktitle = {Applications of Evolutionary Computation - 24th International Conference, EvoApplications 2021},
	year = {2021},
	organization={Springer}
}

@InProceedings{10.1007/978-3-540-71605-1_9,
  author="Harding, Simon
  and Banzhaf, Wolfgang",
  editor="Ebner, Marc
  and O'Neill, Michael
  and Ek{\'a}rt, Anik{\'o}
  and Vanneschi, Leonardo
  and Esparcia-Alc{\'a}zar, Anna Isabel",
  title="Fast Genetic Programming on GPUs",
  booktitle="Genetic Programming",
  year="2007",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="90--101",
  abstract="As is typical in evolutionary algorithms, fitness evaluation in GP takes the majority of the computational effort. In this paper we demonstrate the use of the Graphics Processing Unit (GPU) to accelerate the evaluation of individuals. We show that for both binary and floating point based data types, it is possible to get speed increases of several hundred times over a typical CPU implementation. This allows for evaluation of many thousands of fitness cases, and hence should enable more ambitious solutions to be evolved using GP.",
  isbn="978-3-540-71605-1"
}

@inproceedings{biles2001autonomous,
  title={Autonomous GenJam: eliminating the fitness bottleneck by eliminating fitness},
  author={Biles, John A},
  booktitle={Proceedings of the GECCO-2001 workshop on non-routine design with evolutionary systems},
  volume={7},
  year={2001},
  organization={Morgan Kaufmann San Francisco, CA,, USA}
}

@article{schaul2010metalearning,
  title={Metalearning},
  author={Schaul, Tom and Schmidhuber, J{\"u}rgen},
  journal={Scholarpedia},
  volume={5},
  number={6},
  pages={4650},
  year={2010}
}

@article{DEAP_JMLR2012,
    author    = " F\'elix-Antoine Fortin and Fran\c{c}ois-Michel {De Rainville} and Marc-Andr\'e Gardner and Marc Parizeau and Christian Gagn\'e ",
    title     = { {DEAP}: Evolutionary Algorithms Made Easy },
    pages     = { 2171--2175 },
    volume    = { 13 },
    month     = { jul },
    year      = { 2012 },
    journal   = { Journal of Machine Learning Research }
}

@MASTERSTHESIS{RFIgp2016,
       author = {{Staats}, K.},
        title = "{Genetic programming applied to RFI mitigation in radio astronomy}",
       school = {University of Cape Town},
         year = 2016,
        month = dec,
       adsurl = {https://ui.adsabs.harvard.edu/abs/2016MsT.........58S},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@article{baeta2021speed,
  title={Speed Benchmarking of Genetic Programming Frameworks},
  author={Baeta, Francisco and Correia, Jo{\~a}o and Martins, Tiago and Machado, Penousal},
  journal={GECCO '21: Proceedings of the 2021 Genetic and Evolutionary Computation Conference},
  year={2021}
}

@misc { Luke1998ECJSoftware,
  author       = { Sean Luke },
  title        = { {ECJ} Evolutionary Computation Library },
  year         = { 1998 },
  note         = { Available for free at http://cs.gmu.edu/$\sim$eclab/projects/ecj/  }
}


@inproceedings{eo2001lib,
  author = {Keijzer, Maarten and Merelo Guervós, Juan and Romero, Gustavo and Schoenauer, Marc},
  year = {2001},
  month = {10},
  pages = {231-244},
  title = {Evolving Objects: A General Purpose Evolutionary Computation Library},
  volume = {2310},
  isbn = {978-3-540-43544-0},
  journal = {Artificial Evolution},
  doi = {10.1007/3-540-46033-0_19}
}

@incollection{GOLDBERG199169,
  title = {A Comparative Analysis of Selection Schemes Used in Genetic Algorithms},
  editor = {GREGORY J.E. RAWLINS},
  series = {Foundations of Genetic Algorithms},
  publisher = {Elsevier},
  volume = {1},
  pages = {69-93},
  year = {1991},
  issn = {1081-6593},
  doi = {https://doi.org/10.1016/B978-0-08-050684-5.50008-2},
  url = {https://www.sciencedirect.com/science/article/pii/B9780080506845500082},
  author = {David E. Goldberg and Kalyanmoy Deb},
  keywords = {proportionate selection, ranking selection, tournament selection, Genitor, takeover time, time complexity, growth ratio},
  abstract = {This paper considers a number of selection schemes commonly used in modern genetic algorithms. Specifically, proportionate reproduction, ranking selection, tournament selection, and Genitor (or “steady state”) selection are compared on the basis of solutions to deterministic difference or differential equations, which are verified through computer simulations. The analysis provides convenient approximate or exact solutions as well as useful convergence time and growth ratio estimates. The paper recommends practical application of the analyses and suggests a number of paths for more detailed analytical investigation of selection techniques.}
}

@misc{agrawal2019tensorflow,
  title={TensorFlow Eager: A Multi-Stage, Python-Embedded DSL for Machine Learning}, 
  author={Akshay Agrawal and Akshay Naresh Modi and Alexandre Passos and Allen Lavoie and Ashish Agarwal and Asim Shankar and Igor Ganichev and Josh Levenberg and Mingsheng Hong and Rajat Monga and Shanqing Cai},
  year={2019},
  eprint={1903.01855},
  archivePrefix={arXiv},
  primaryClass={cs.PL}
}

@inproceedings{push3Stack,
  author = {Spector, Lee and Klein, Jon and Keijzer, Maarten},
  title = {The Push3 Execution Stack and the Evolution of Control},
  year = {2005},
  isbn = {1595930108},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1068009.1068292},
  doi = {10.1145/1068009.1068292},
  abstract = {The Push programming language was developed for use in genetic and evolutionary computation systems, as the representation within which evolving programs are expressed. It has been used in the production of several significant results, including results that were awarded a gold medal in the Human Competitive Results competition at GECCO-2004. One of Push's attractive features in this context is its transparent support for the expression and evolution of modular architectures and complex control structures, achieved through explicit code self-manipulation. The latest version of Push, Push3, enhances this feature by permitting explicit manipulation of an execution stack that contains the expressions that are queued for execution in the interpreter. This paper provides a brief introduction to Push and to execution stack manipulation in Push3. It then presents a series of examples in which Push3 was used with a simple genetic programming system (PushGP) to evolve programs with non-trivial control structures.},
  booktitle = {Proceedings of the 7th Annual Conference on Genetic and Evolutionary Computation},
  pages = {1689–1696},
  numpages = {8},
  keywords = {stack-based genetic programming, parity, push, Fibonacci sequence, reversing a list, factorial, sorting, iteration, recursion, combinators, exponentiation},
  location = {Washington DC, USA},
  series = {GECCO '05}
}

@inproceedings{Philox2011,
  author = {Salmon, John K. and Moraes, Mark A. and Dror, Ron O. and Shaw, David E.},
  title = {Parallel Random Numbers: As Easy as 1, 2, 3},
  year = {2011},
  isbn = {9781450307710},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2063384.2063405},
  doi = {10.1145/2063384.2063405},
  abstract = {Most pseudorandom number generators (PRNGs) scale poorly to massively parallel high-performance computation because they are designed as sequentially dependent state transformations. We demonstrate that independent, keyed transformations of counters produce a large alternative class of PRNGs with excellent statistical properties (long period, no discernable structure or correlation). These counter-based PRNGs are ideally suited to modern multi-core CPUs, GPUs, clusters, and special-purpose hardware because they vectorize and parallelize well, and require little or no memory for state. We introduce several counter-based PRNGs: some based on cryptographic standards (AES, Threefish) and some completely new (Philox). All our PRNGs pass rigorous statistical tests (including TestU01's BigCrush) and produce at least 264 unique parallel streams of random numbers, each with period 2128 or more. In addition to essentially unlimited parallel scalability, our PRNGs offer excellent single-chip performance: Philox is faster than the CURAND library on a single NVIDIA GPU.},
  booktitle = {Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis},
  articleno = {16},
  numpages = {12},
  location = {Seattle, Washington},
  series = {SC '11}
}

@article{Orzechowski_2018,
   title={Where are we now?},
   ISBN={9781450356183},
   url={http://dx.doi.org/10.1145/3205455.3205539},
   DOI={10.1145/3205455.3205539},
   journal={Proceedings of the Genetic and Evolutionary Computation Conference},
   publisher={ACM},
   author={Orzechowski, Patryk and La Cava, William and Moore, Jason H.},
   year={2018},
   month={Jul}
}

@inproceedings{GP_Better_Benchmarks,
  author = {McDermott, James and White, David R. and Luke, Sean and Manzoni, Luca and Castelli, Mauro and Vanneschi, Leonardo and Jaskowski, Wojciech and Krawiec, Krzysztof and Harper, Robin and De Jong, Kenneth and O'Reilly, Una-May},
  title = {Genetic Programming Needs Better Benchmarks},
  year = {2012},
  isbn = {9781450311779},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2330163.2330273},
  doi = {10.1145/2330163.2330273},
  abstract = {Genetic programming (GP) is not a field noted for the rigor of its benchmarking. Some of its benchmark problems are popular purely through historical contingency, and they can be criticized as too easy or as providing misleading information concerning real-world performance, but they persist largely because of inertia and the lack of good alternatives. Even where the problems themselves are impeccable, comparisons between studies are made more difficult by the lack of standardization. We argue that the definition of standard benchmarks is an essential step in the maturation of the field. We make several contributions towards this goal. We motivate the development of a benchmark suite and define its goals; we survey existing practice; we enumerate many candidate benchmarks; we report progress on reference implementations; and we set out a concrete plan for gathering feedback from the GP community that would, if adopted, lead to a standard set of benchmarks.},
  booktitle = {Proceedings of the 14th Annual Conference on Genetic and Evolutionary Computation},
  pages = {791–798},
  numpages = {8},
  keywords = {genetic programming, benchmarks},
  location = {Philadelphia, Pennsylvania, USA},
  series = {GECCO '12}
}

@article{Pagie1997,
  author = {Pagie, Ludo and Hogeweg, Paulien},
  title = {Evolutionary Consequences of Coevolving Targets},
  year = {1997},
  issue_date = {Winter 1997},
  publisher = {MIT Press},
  address = {Cambridge, MA, USA},
  volume = {5},
  number = {4},
  issn = {1063-6560},
  url = {https://doi.org/10.1162/evco.1997.5.4.401},
  doi = {10.1162/evco.1997.5.4.401},
  abstract = {Most evolutionary optimization models incorporate a fitness evaluation that is based on a predefined static set of test cases or problems. In the natural evolutionary process, selection is of course not based on a static fitness evaluation. Organisms do not have to combat every existing disease during their lifespan; organisms of one species may live in different or changing environments; different species coevolve. This leads to the question of how information is integrated over many generations.This study focuses on the effects of different fitness evaluation schemes on the types of genotypes and phenotypes that evolve. The evolutionary target is a simple numerical function. The genetic representation is in the form of a program (i.e., a functional representation, as in genetic programming). Many different programs can code for the same numerical function. In other words, there is a many-to-one mapping between “genotypes” (the programs) and “phenotypes”. We compare fitness evaluation based on a large static set of problems and fitness evaluation based on small coevolving sets of problems. In the latter model very little information is presented to the evolving programs regarding the evolutionary target per evolutionary time step. In other words, the fitness evaluation is very sparse. Nevertheless the model produces correct solutions to the complete evolutionary target in about half of the simulations. The complete evaluation model, on the other hand, does not find correct solutions to the target in any of the simulations. More important, we find that sparse evaluated programs are better generalizable compared to the complete evaluated programs when they are evaluated on a much denser set of problems. In addition, the two evaluation schemes lead to programs that differ with respect to mutational stability; sparse evaluated programs are less stable than complete evaluated programs.},
  journal = {Evol. Comput.},
  month = dec,
  pages = {401–418},
  numpages = {18},
  keywords = {generalizability, information integration, genetic programming, Coevolution, mutational stability, genotype-phenotype mapping}
}




  



  

